var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import JTurtle from './turtle-core';
var Turtle = function (_a) {
    var _b = _a.width, width = _b === void 0 ? 480 : _b, _c = _a.height, height = _c === void 0 ? 320 : _c, _d = _a.draw, draw = _d === void 0 ? defaultDraw : _d, _e = _a.animated, animated = _e === void 0 ? true : _e, _f = _a.pixelated, pixelated = _f === void 0 ? true : _f, _g = _a.autostroke, autostroke = _g === void 0 ? true : _g, _h = _a.style, style = _h === void 0 ? {} : _h, rest = __rest(_a, ["width", "height", "draw", "animated", "pixelated", "autostroke", "style"]);
    var rCanvas = React.useRef(null);
    var rTurtle = React.useRef();
    React.useEffect(function () {
        if (rTurtle.current) {
            var canvas = rCanvas.current;
            if (canvas) {
                rTurtle.current.size = {
                    width: canvas.width,
                    height: canvas.height,
                };
            }
        }
    }, [height, width]);
    React.useEffect(function () {
        var canvas = rCanvas.current;
        var stop = false;
        if (canvas) {
            canvas.height = canvas.offsetHeight;
            canvas.width = canvas.offsetWidth;
            var turtle = (rTurtle.current = new JTurtle(canvas));
            var walk_1 = draw(turtle, turtle.height, turtle.width);
            if (walk_1) {
                var walkLoop_1 = function (i) {
                    if (i > 100000) {
                        console.log('Bailed');
                        return;
                    }
                    var stillWalking = walk_1(i);
                    if (stillWalking && !stop) {
                        if (animated) {
                            requestAnimationFrame(function () {
                                walkLoop_1(i + 1);
                            });
                        }
                        else {
                            walkLoop_1(i + 1);
                        }
                    }
                    else {
                        console.log('done');
                    }
                };
                walkLoop_1(0);
            }
            else {
            }
        }
        return function () {
            stop = true;
        };
    }, [height, width, draw, animated]);
    return (React.createElement("div", __assign({}, rest, { style: __assign(__assign({ imageRendering: pixelated ? 'pixelated' : 'auto' }, style), { position: 'relative', height: height,
            width: width }) }),
        React.createElement("canvas", { ref: rCanvas, height: height, width: width, style: {
                position: 'absolute',
                top: 0,
                left: 0,
                height: height,
                width: width,
            } })));
};
var defaultDraw = function (turtle) {
    turtle.setcolor('#99df66');
    return function (i) {
        turtle
            .clear()
            .pendown()
            .transformColor(function (c) { return c.rotate(2); })
            .setlinewidth(2 + (i % 2))
            .circle(i, 90, 0)
            .penup()
            .stroke();
        return i < 200;
    };
};
export default Turtle;
